# Java内存模型

Java Memory Model，简称JMM

## JVM内存结构

JVM内部使用的Java内存模型， 在逻辑上将内存划分为 线程栈（thread stacks）和堆内存 （heap）两个部分。

JVM中，每个正在运行的线程，都有自己的线程栈。 线程栈包含了当前正在执行的方法链/调用链上的所有方法的状态信息。
所以线程栈又被称为“ 方法栈”或“ 调用栈”（call stack）。 线程在执行代码时，调用栈中的信息会一直在变化。

线程栈里面保存了调用链上正在执行的所有方法中的局部变量。
- 每个线程都只能访问自己的线程栈。
- 每个线程都不能访问(看不见)其他线程的局部变量。

即使两个线程正在执行完全相同的代码，但每个线程都会在自己的线程栈内创建对应代码中声明的局部变量。 所以每个线程都有一份自己的局部变量副本。

- 所有原生类型的局部变量都存储在线程栈中，因此对其他线程是不可见的。
- 线程可以将一个原生变量值的副本传给另一个线程，但不能共享原生局部变量本身。
- 堆内存中包含了Java代码中创建的所有对象，不管是哪个线程创建的。 其中也涵盖了包装类型（例如Byte ， Integer ， Long 等）。
- 不管是创建一个对象并将其赋值给局部变量， 还是赋值给另一个对象的成员变量， 创建的对象都会被保存到堆内存中。

如果是原生数据类型的局部变量，那么它的内容就全部保留在线程栈上。
如果是对象引用，则栈中的局部变量槽位中保存着对象的引用地址，而实际的对象内容保存在堆中。
对象的成员变量与对象本身一起存储在堆上, 不管成员变量的类型是原生数值，还是对象引用。
类的静态变量则和类定义一样都保存在堆中。

总结一下：方法中使用的原生数据类型和对象引用地址在栈上存储；对象、对象成员与类定义、静态变量在堆上。

## 栈内存的结构

## 堆内存的结构

## CPU指令与乱序执行

## JMM简介

## 小结

1. JVM的内存区域分为: 堆内存 和 栈内存；
2. 堆内存的实现可分为两部分: 堆(Heap) 和 非堆(Non‐Heap) ;
3. 堆主要由GC负责管理，按分代的方式一般分为: 老年代+年轻代；年轻代=新生代+存活区；
4. CPU有一个性能提升的利器: 指令重排序；
5. JMM规范对应的是 JSR133, 现在由Java语言规范和JVM规范来维护；
6. 内存屏障的分类与作用。

## 经验总结

-Xmx 最大堆内存
-Xms 最小堆内存
-Xmn 新生代的大小
-XX:MaxPermSize：持久代的最大值, -XX:PermSize:持久代的初始大小
-Xss 线程栈的大小

