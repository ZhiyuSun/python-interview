# 事务

## 数据库事务的四大特性

ACID
- 原子性（Atomic）
- 一致性（Consistencey）
- 隔离性（Isolation）：事务之间不互相影响
- 持久性（Durability）：事务一旦提交，对数据库的修改是永久的

## 事务隔离级别以及各级别下的并发访问问题

事务并发访问引起的问题以及如何避免
- 更新丢失：MySQL所有事务隔离级别在数据库层面上均可避免
- 脏读——READ-COMMITED事务隔离级别以上可避免。事务允许读到未提交的事务，前一个事务如果回滚，会出错
- 不可重复度——REPEATABLE-READ事务隔离级别以上可避免。一个事务读的时候，另一个事务在修改，导致前面的事务读的两个数据不一致
- 幻读——SERIALIZABLE事务隔离级别可避免。一个事务在更新的时候，如果另一个事务插入或删除行，第一个事务会发现更新的数目多了

总结：

事务隔离级别（从低到高）    更新丢失    脏读    不可重复读  幻读
未提交读                    避免        发生    发生    发生
已提交读                    避免        避免    发生    发生 （Oracle默认）
可重复读                    避免        避免    避免    发生 （MySQL默认）
串行化                      避免        避免    避免    避免

出于性能考虑，事务隔离级别越高，越容易降低并发度
事务隔离级越高，串行化越高，并发度越低

## InnoDB可重复读隔离级别下如何避免幻读

表象：快照读（非阻塞读）——伪MvCC
内在：next-key锁（行锁+gap锁）

当前读和快照读
当前读：select ……lock in share mode（共享锁）, select …… for update（排它锁）
当前读：update,delete,insert （排它锁）
快照读：不加锁的非阻塞读，select

RC隔离级别下，当前读和快照读的结果是一样的
RR隔离级别下，当前读返回最新版本，快照读返回历史版本。创建快照的时机决定了读的版本

gap锁，好难，根本记不住

## RC、RR级别下的Innodb非阻塞读如何实现

快照读——非阻塞读

## redo log undo log bin log

## 事务隔离做不好会产生
- 脏读：读到还未提交的内容
- 不可重复度：两次读读到更新后的数据
- 幻读：两次读读到新增的数据

## 事务隔离级别
- 读未提交：脏读，不可重复读，幻读
- 读已提交：不可重复读，幻读
- 可重复读：幻读（MYSQL默认隔离级别，MySQL可解决（MVCC+当前读，搞定了这个问题）
- 串行化

知鱼君注：
select for update 是当前读，会阻塞
select 是快照读（mvcc，记录最早读到的版本）

幻读和MVCC

## Mysql 在可重复读的隔离级别下会不会有幻读的情况，为什么？

InnoDB 是如何解决幻读的。

在可重复读的情况下，InnoDB 可以通过 Next-Key 锁 +MVCC 来解决幻读问题。

在读已提交的情况下，即使采用了 MVCC 方式也会出现幻读。如果我们同时开启事务 A 和事务 B，先在事务 A 中进行某个条件范围的查询，读取的时候采用排它锁，在事务 B 中增加一条符合该条件范围的数据，并进行提交，然后我们在事务 A 中再次查询该条件范围的数据，就会发现结果集中多出一个符合条件的数据，这样就出现了幻读。

出现幻读的原因是在读已提交的情况下，InnoDB 只采用记录锁（Record Locking）。这里要介绍下 InnoDB 三种行锁的方式：
- 记录锁：针对单个行记录添加锁。
- 间隙锁（Gap Locking）：可以帮我们锁住一个范围（索引之间的空隙），但不包括记录本身。采用间隙锁的方式可以防止幻读情况的产生。
- Next-Key 锁：帮我们锁住一个范围，同时锁定记录本身，相当于间隙锁 + 记录锁，可以解决幻读的问题。

在隔离级别为可重复读时，InnoDB 会采用 Next-Key 锁的机制，帮我们解决幻读问题。

还是这个例子，我们能看到当我们想要插入球员艾利克斯·伦（身高 2.16 米）的时候，事务 B 会超时，无法插入该数据。这是因为采用了 Next-Key 锁，会将 height>2.08 的范围都进行锁定，就无法插入符合这个范围的数据了。然后事务 A 重新进行条件范围的查询，就不会出现幻读的情况。

极客时间 SQL必知必会
https://time.geekbang.org/column/article/120351

## MySQL事务是如何实现的？

- 原子性：通过undo log实现的。每条数据变更都伴随一条undo log日志的生成，当系统发生错误或执行回滚根据undo log做逆向操作
- 持久性：通过redo log实现的。redo log记录了数据的修改日志。数据持久化到磁盘，先是储存到缓冲池里，然后缓冲池中的数据定期同步到磁盘中，如果系统宕机，可能会丢失数据，系统重启后会读取redo log恢复数据
- 隔离性：mysql数据库通过MVCC + next-key机制实现了隔离性
- 一致性：以上3大特性，保障了事务的一致性

## Binlog 和 Redo log 的区别是什么，分别是什么用？

- binlog是二进制文件，记录了对数据库执行更改的所有操作，不包括 select、show，因为这两个操作没有对数据本身做修改。但是若操作了数据，但是数据没有发生变化，也会记录到binlog。常用来数据恢复，数据备份。
- redo log又叫做重做日志文件，记录了事务的修改，不管事务是否提交都记录下来。在实例和介质失败时，InnoDB存储引擎会使用redo log恢复到之前的状态，保证数据的完整性

## 有了MySQL事务隔离级别，为什么有并发请求的时候还要加锁（乐观锁，悲观锁）呢？

https://bbs.csdn.net/topics/392134885

https://www.cnblogs.com/hbuwdx/p/6593145.html

https://blog.csdn.net/qq_21294095/article/details/84888802

## 参考资料

https://blog.csdn.net/w139074301/article/details/112004430