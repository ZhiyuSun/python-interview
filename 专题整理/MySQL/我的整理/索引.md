# 索引

## 为什么要使用索引

避免全表扫描查找数据，提升查询效率

## 什么样的信息能成为索引

有一定区分度的字段

## 索引的数据结构

从二叉查找数上阵

时间复杂度O(logn)，容易退化成O(n)
深度每增加1，就会增加一次IO，红黑树也这样

B-tree
- 跟节点至少包括两个孩子
- 树中每个节点最多含有m个孩子（m>=2）
- 除跟节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子
- 所有叶子都位于同一层

让每个索引快尽可能存储更多信息

B+-Tree
- 非叶子节点的子树指针与关键字个数相同
- 非叶子节点的子树指针P[i]，指向关键字值（K[i],K[i+1]）的子树
- 非叶子节点仅用来索引，数据都保存在叶子节点中
- 所有叶子节点均有一个指针指向下一个节点（方便做范围统计）

B+Tree更适合用来做存储索引
- B+树的磁盘读写代价更低（非叶子节点不存数据，能读的量就越多）
- B+树的查询效率更加稳定（任何关键字查找一定要走到叶子节点的路）
- B+树更有利于对数据库的扫描（范围查询有更高的性能）

Hash索引

效率高，
缺点：
- 仅仅满足=、 in，不能使用范围查询
- 无法被用来避免数据的排序操作
- 不能利用部分索引键查询（组合索引）
- 不能避免表扫描
- 遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高

## 密集索引和稀疏索引的区别

我感觉就是聚簇索引和非聚簇索引。

Innodb
- 若一个主键被定义，该主键则作为密集索引
- 如没有主键被定义，该表的第一个唯一非空索引则作为密集索引
- 若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）
- 非主键索引存储相关键位和其对应的主键值，包含两次查找

myisam，只要一次，跟innodb不同

inndob的索引和数据是存一块的，myIsam是分开的

## 如何定位并优化慢sql

- 根据慢查询日志定位慢查询sql
- 使用explain等工具分析sql
- 修改sql或者尽量让sql走索引


long_query_time
show_query_log
show_query_log_file

explain关键字段

type:
system>const>eq_ref>ref>fulltext>ref_or_null>index_merge>unique_subquery>index_subquery>range>index>all
all表明走的是全表扫描，需要优化

extra:
出现下面两个意味着MySQL根本不能使用索引，效率会受到重大影响。应尽可能对此进行优化。
using filesort:表示MySQL会对结果使用一个外部索引排序，而不是从表里按索引次序读到相关内容。可能在内存或者磁盘上进行排序。MySQL中无法利用索引完成的排序操作称为“文件排序”
using temporary:表示MySQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by

问题：count(*),count(1),count(字段)的区别

force index去测试各种索引

## 联合索引的最左匹配原则

- 最左前缀匹配原则：mysql会一直向右匹配直到遇到范围查询（>,<,between,like）就停止匹配，比如a=3 and b=4 and c>5 and d=6，如果建立（a，b,c,d）顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整
- =和in可以乱序，比如a=1 and b=2 and c=3 建立（a,b,c）索引可以任意顺序，mysql的查询优化器会帮你优化所以可以识别的形式

## 联合索引的最左匹配原则的成因

只有后面的，没法走b+树索引

a,b,c的联合索引，b+树是按照a建立的

## 索引是建立的越多越好吗

- 数据量小的表不需要建立索引，建立会增加额外的索引开销
- 数据变更需要维护索引，因此更多的索引意味着更多的维护成本
- 更多的索引意味着也需要更多的空间

## 不建议用UUID为主键

数字比字符串要快很多

字符串的比较太慢了

## 什么样的查询语句用不到索引

函数计算
数据类型转换
like %开头
or运算
复合索引，没有左边字段

## 索引类型分类

B+树
- 所有内容都在叶子节点
- 叶子节点通过指针连接
- 方便范围查询

Hash
- 范围查询时不建议用Hash

## 索引形态分类

- 聚簇索引：直接通过索引路由找到数据。聚簇索引是有一个
- 非聚簇索引：通过磁盘寻址去找到数据。非聚簇索引有很多

不会无限制增加非聚簇索引，增加insert,delete开销

## 索引优化

- 经常被查询的区分度高的列做索引（比如status，区分度低，降级为全表扫描）（20-40%左右，70%没意义）
- 做左原则（a=3 and b>4 and c=5 是用到a和b，c不能用在范围之后。a=3 and b like "kk%" and c=5使用到 a,b,c）
- 回盘排序（排序列联合索引）
- 覆盖索引(select a,b from , 减少一跳)
- 小表驱动大表

## 索引调优

- system：仅一行
- const：主键or唯一键的常量等值查询
- eq_ref:主键or唯一键的扫描或关联查询
- ref:非唯一索引的常量等值查询
- range:索引的范围查询
- index:索引全查询
- all:遍历表查询

优化到至少range范围

## 极客时间专栏SQL必知必会关于索引的讨论

一、数据库索引，为什么不适用用二叉树：
1. 平衡二叉树必须满足（所有节点的左右子树高度差不超过1）。执行插入还是删除操作，只要不满足上述条件，就要通过旋转来保持平衡，而旋转是非常耗时的，所以AVL树适合用于查找多的情况。
2. 二叉树的数据结构，会导致“深度”，比较深，这种“瘦高”的特性，加大了平均查询的磁盘IO次数，随着数据量的增多，查询效率也会受到影响；

二、B+ 树和 B 树在构造和查询性能上有什么差异呢？
B+ 树的中间节点并不直接存储数据。
1. B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
2. B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。
3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。


## 参考资料

leetcode上的索引讨论：
https://leetcode-cn.com/circle/discuss/F7bKlM/
https://leetcode-cn.com/circle/discuss/N5PqWI/


因为在数据库中，涉及磁盘的随机IO的访问是数据库中最耗时的操作之一。

2020字节跳动数据库面试题及答案：
https://blog.csdn.net/w139074301/article/details/112004430