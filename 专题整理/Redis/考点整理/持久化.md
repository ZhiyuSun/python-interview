# 持久化

RDB（快照）持久化：保存某个时间点的全量数据快照。

平衡性能和安全

- SAVE：阻塞Redis的服务器进程，直到RDB文件被创建完毕
- BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器进程


## 自动化出发RDB持久化的方式

- 根据redis.conf配置里的SAVE m n定时出发（用的是BGSAVE）
- 主从复制时，主节点自动触发
- 执行Debug Reload
- 执行Shutdown且没有开启AOF持久化

## BGSAVE原理

- 系统调用fork():创建进程，实现了copy-on-write
- copy-on-write：如果有多个调用者同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变。

## RDB持久化缺点

- 内存数据的全量同步，数据量大会由于IO而严重影响性能
- 可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据

## AOF(Append-Only-File)持久化：保存写状态

- 记录下除了查询以外的所有变更数据库状态的指令
- 以append的形式追加保存在AOF文件中（增量）

## 日志重写解决AOF文件大小不断增大的问题，原理如下：

- 调用fork()，创建一个子进程
- 子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件
- 主进程持续将新的变动同时写到内存和原来的AOF里
- 主进程获取子进程重写AOF的完成信号，往新AOF同步增量变动
- 使用新的AOF文件替换掉旧的AOF文件

## Redis数据的恢复

RDB和AOF文件共存情况下的恢复流程

## RDB和AOF的缺点
- RDB
    - 优点：全量数据快照，文件小，恢复快
    - 缺点：无法保存最近一次快照之后的数据
- AOF
    - 优点：可读性高，适合保存增量数据，数据不易丢失
    - 缺点：文件体积大，恢复时间长

## Redis如何做持久化

RDB-AOF混合持久化方式
- BGSAVE做镜像全量持久化，AOF做增量持久化

### 数据持久化

- rdb(rdb备份)
- aof(到期写：900s写一次。到次数写：900写一次)