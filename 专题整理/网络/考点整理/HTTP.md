# HTTP

状态行+响应头+响应正文

## HTTP简介

特点：
- 支持客户/服务器模式
- 简单快速
- 灵活
- 无连接
- 无状态

面试以1.1为准

http1.1 keep-alive

请求/响应步骤：
- 客户端连接到web服务器
- 发送HTTP请求
- 服务器接受请求并返回HTTP响应
- 释放TCP连接
- 客户端浏览器解析HTML内容

在浏览器地址栏键入URL，按下回车之后经历的流程
- DNS解析
- TCP连接。和服务建立
- 发送HTTP连接
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染页面
- 连接结束

HTTP状态码
- 1xx：指示信息——表示请求已接收，继续处理
- 2xx：成功——表会请求已被成功接收、理解、接受
- 3xx：重定向——要完成请求必须进行更进一步的操作
- 4xx：客户端错误——请求有语法错误或请求无法实现
- 5xx：服务端错误——服务器未能实现合法的请求

常见状态码：
- 200 ok：正常返回信息
- 400 Bad Request:客户端请求有语法错误，不能被服务器所理解
- 401 unauthorized：请求未经授权
- 403 forbidden：服务器收到请求，但是拒绝提供服务
- 404 Not Found：请求资源不存在，eg，输入了错误的url
- 500 Internal Server Error：服务器发生不可预期的错误
- 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。

GET请求和POST请求的区别
- HTTP报文层面：GET将请求信息放在URL（有长度限制）,POST放在报文体中
- 数据库层面：GET符合幂等性和安全性，POST不符合
- 其他层面：GET可以被缓存、被存储，而POST不行

Cookie和Session的区别
- Cookie
    - 是由服务器发给客户端的特殊信息，以文本的形式存放在客户端
    - 客户端再次请求的时候，会把cookie回发
    - 服务器接收到后，会解析Cookie生成与客户端相对应的内容
- Session的简介
    - 服务器端的机制，在服务器上保存的信息
    - 解析客户端请求并操作session id，按需保存状态信息
- Session的实现方式
    - 使用Cookie来实现（JSESSIONID）
    - 使用URL回写来实现
- Cookie和Session的区别
    - Cookie数据存放在客户的浏览器上，Session数据放在服务器上
    - Session相对于Cookie更安全
    - 若考虑减轻服务器负担，应当使用Cookie

## HTTP和HTTPS的区别

SSL（Security Sockets Layer，安全套接层）
- 为网络通信提供安全及数据完整性的一种安全协议
- 是操作系统对外的API，SSL3.0后更名为TLS
- 采用身份验证和数据加密保证网络通信的安全和数据的完整性

加密的方式
- 对称加密：加密和解密都使用同一个密钥
- 非对称加密：加密使用的密钥和解密使用的密钥是不相同的
- 哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆
- 数字签名：证明某个消息或者文件是某人发出/认同的

HTTPS数据传输流程
- 浏览器将支持的加密算法信息发送给服务器
- 服务器选择一套浏览器支持的加密算法，以证书的形式回发浏览器
- 浏览器验证证书合法性，并结合证书公钥加密信息发送给服务器
- 服务器使用私钥解密信息，验证哈希，加密响应消息回发浏览器
- 浏览器解密响应消息，并对消息进行验真，之后进行加密交互数据

HTTP和HTTPS的区别
- HTTPS需要CA申请证书，HTTP不需要
- HTTPS密文传输，HTTP明文传输
- 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口
- HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全

Socket简介
（pid是本地唯一继承
IP地址+协议+端口号）
Socket是对TCP/IP协议的抽象，是操作系统对外开放的接口

Socket通信流程

Socket相关的面试题，javabasic.socket

### https加密

- 非对称运算
- 对称运算

HTTPS 在 HTTP 与 TCP 层之间加⼊了 TLS 协议，来解决上述的⻛险。

HTTPS 是应⽤层协议，需要先完成 TCP 连接建⽴，然后⾛ TLS 握⼿过程后，才能建⽴通信安全的连接。

事实上，不同的密钥交换算法，TLS 的握⼿过程可能会有⼀些区别。

这⾥先简单介绍下密钥交换算法，因为考虑到性能的问题，所以双⽅在加密应⽤信息时使⽤的是对称加密密钥，⽽对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使⽤⾮对称加密的⽅式来保护对称加密密钥的协商，这个⼯作就是密钥交换算法负责的。

TLS第一次握手
- 客户端⾸先会发⼀个「Client Hello」消息。
- 消息⾥⾯有客户端使⽤的 TLS 版本号、⽀持的密码套件列表，以及⽣成的随机数（Client Random），这个随机数会被服务端保留，它是⽣成对称加密密钥的材料之⼀。

TLS第二次握手
- 当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否⽀持，和从密码套件列表中选择⼀个密码套件，以及⽣成随机数（Server Random）。
- 接着，返回「Server Hello」消息，消息⾥⾯有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了⼀个合适的密码套件。其实这两个随机数是后续作为⽣成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使⽤的对称加密密钥。
- 然后，服务端为了证明⾃⼰的身份，会发送「Server Certificate」给客户端，这个消息⾥含有数字证书。
- 随后，服务端发了「Server Hello Done」消息，⽬的是告诉客户端，我已经把该给你的东⻄都给你了，本次打招呼完毕。

TLS 第三次握⼿
- 客户端验证完证书后，认为可信则继续往下⾛。接着，客户端就会⽣成⼀个新的随机数 (pre-master)，⽤服务器的 RSA 公钥加密该随机数，通过「Change Cipher Key Exchange」消息传给服务端。
- 服务端收到后，⽤ RSA 私钥解密，得到客户端发来的随机数 (pre-master)。
- ⾄此，客户端和服务端双⽅都共享了三个随机数，分别是 Client Random、Server Random、pre-master。
- 于是，双⽅根据已经得到的三个随机数，⽣成会话密钥（Master Secret），它是对称密钥，⽤于对后续的 HTTP请求/响应的数据加解密。
- ⽣成完会话密钥后，然后客户端发⼀个「Change Cipher Spec」，告诉服务端开始使⽤加密⽅式发送消息。
- 然后，客户端再发⼀个「Encrypted Handshake Message（Finishd）」消息，把之前所有发送的数据做个摘要，再⽤会话密钥（master secret）加密⼀下，让服务器做个验证，验证加密通信是否可⽤和之前握⼿信息是否有被中途篡改过。
- 可以发现，「Change Cipher Spec」之前传输的 TLS 握⼿数据都是明⽂，之后都是对称密钥加密的密⽂

TLS 第四次握⼿
- 服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双⽅都验证加密和解密没问题，那么握⼿正式完成。
- 最后，就⽤「会话密钥」加解密 HTTP 请求和响应了。

### http2.0

- 二进制传输（增加传输效率，减少带宽占用）
- 多路复用内容数据，（包1-4 HTML 包5-8 CSS html数据 css数据）
- 服务端推送（访问html，服务端push css js）

### 长连接和短连接

- 短连接：建立连接——数据传输——关闭连接
- 长连接：Connection: keep-alive。保持TCP连接不断开
- 如何区分不同的HTTP请求呢？Content-Length | Transfer-Encoding:chunked

### cookie和aession



## 我的新得

我们可以知道，非对称加密在性能上不如对称加密，那是否能将两者结合起来呢？例如，公钥私钥主要用于传输对称加密的秘钥，而真正的双方大数据量的通信都是通过对称加密进行的。


## 参考资料

小林coding，图解网络
极客时间：https://time.geekbang.org/column/article/9492