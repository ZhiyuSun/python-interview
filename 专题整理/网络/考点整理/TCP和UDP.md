# TCP和UDP

## TCP和UDP的区别

面向连接、可靠的、基于字节流
无连接、不可靠、面向报文

TCP三次握手
确认机制
TCP有缓冲区

## TCP/IP

OSI的实现：TCP/IP

应用层：应表会  HTTP数据
传输层：传输层  TCP首部
网络层：网络层  IP首部
链路层：物数    以太网首部

## 说说TCP的三次握手

传输控制协议TCP简介：
- 面向连接的，可靠的，基于字节流的传输层通信协议
- 将应用层的数据流分隔成报文段并发送给目标节点的TCP层
- 数据包都有序号，对方收到则发送ACK确认，未收到则重传
- 使用校验和来检验数据在传输过程中是否有误

TCP Flags
- URG：紧急指针标志
- ACK：确认序号标志
- PSH：push标志
- RST：重置连接标志
- SYN：同步序号，用于建立连接过程
- FIN：finish标志，用于释放连接

握手是为了建立连接，TCP三次握手的流程图如下：
(pic)
在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。
第一次握手：建立连接时，客户端发送SYN包（syn=j）到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到SYN包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

不要用大白话来回答，要用行话来回答，不然显得不专业

## 为什么需要三次握手才能建立起连接？

为了初始化Sequence Number的初始值

todo

## 首次握手的隐患---SYN超时

## 建立连接后，Client出现故障怎么办

保活机制
- 向对方发送保活探测报文，如果未收到响应则继续发送
- 尝试次数达到保活探测数仍未收到响应则中断连接

## TCP的四次挥手

挥手是为了终止连接，TCP四次挥手的流程图如下

- 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态
- 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态
- 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态；
- 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手

这几个状态图要弄清楚

为什么会有TIME_WAIT状态？
- 确保有足够的时间让对方收到ACK包
- 避免新旧连接混淆

为什么需要四次挥手才能断开连接？
- 因为全双工，发送方和接收方都需要FIN报文和ACK报文

服务器出现大量CLOSE_WAIT状态的原因
- 对方关闭socket连接，我方忙于读或写，没有及时关闭连接
    - 检查代码，特别是释放资源的代码
    - 检查配置，特别是处理请求的线程配置（可用netstat排查）

netstat -n | awk '/^tcp/{++S[$NF]}END{for (a in S)} print a,S[a]'

## UDP

源端口，目标端口，长度，校验值

特点
- 面向非连接
- 不维护连接状态，支持同时向多个客户端传输相同的消息
- 数据包报头只有8个字节，额外开销较小
- 吞吐量只受限于数据生成速率、传输速率以及机器性能
- 尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表
- 面向报文，不对应用程序提交的报文信息进行拆分或者合并

## TCP和UDP的区别

结论：
- 面向连接VS无连接
- 可靠性
- 有序性
- 速度
- 量级

## TCP的滑动窗口

RTT和RTO:
- RTT：发送一个数据包到收到对应的ACK，所花费的时间
- RTO：重传时间间隔

TCP使用滑动窗口做流量控制与乱序重排
- 保证TCP的可靠性
- 保证TCP的流控特性

这个有点难


## 什么是TCP

TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。

- 面向连接：一定是一对一才能连接，不能像UDP协议可以一个主机同时向多个主机发送消息，也就是一对多无法做到。
- 可靠的：无论网络链路中出现了怎样的链路变化，TCP都可以保证一个报文一定能到达接收端。
- 字节流：消息是没有边界的，所以无论我们消息有多大都可以进行传输。并且消息是有序的，当前一个消息没有收到的时候，即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对重复的报文会自动丢弃。

### 什么是面向连接

所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。

TCP 提供可靠交付。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。

IP 包是没有任何可靠性保证的。UDP 继承了 IP 包的特性，不保证不丢失，不保证按顺序到达。

### 什么是面向字节流

TCP 是面向字节流的。发送的时候发的是一个流，没头没尾。IP 包可不是一个流，而是一个个的 IP 包。之所以变成了流，这也是 TCP 自己的状态维护做的事情。而 UDP 继承了 IP 的特性，基于数据报的，一个一个地发，一个一个地收。

还有 TCP 是可以有拥塞控制的。它意识到包丢弃了或者网络的环境不好了，就会根据情况调整自己的行为，看看是不是发快了，要不要发慢点。UDP 就不会，应用让我发，我就发，管它洪水滔天。

## TCP和UDP的区别

连接
- TCP是面向连接的传输层协议，传输数据前先要建立连接
- UDP是不需要连接，即刻传输数据

服务对象
- TCP是一对一的两点服务，即一条连接只有两个端点
- UDP支持一对一、一对多、多对多的交互通信

可靠性
- TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。
- UDP是尽最大努力交付，不保证可靠交付数据。

拥塞控制、流量控制
- TCP有拥塞控制和流量控制机制，保证数据传输的安全性
- UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率

首部开销
- TCP首部长度较长，会有一定的开销，首部在没有使用选项字段时是20个字节，如果使用了选项字段则会变长的。
- UDP首部只有8个字节，并且是固定不变的，开销较小。

传输方式
- TCP是流式传输，没有边界，但保证顺序和可靠
- UDP是一个包一个包的发送，是有边界的，但可能会丢包和乱序

由于TCP是面向连接，能保证数据的可靠性交付，因此经常用于：
- FTP 文件传输
- HTTP / HTTPS

由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：
- 包总量较少的通信，如 DNS 、SNMP 等
- 视频、音频等多媒体通信
- 广播通信


| 类型 |是否面向连接|传输可靠性|传输形式|传输效率|所需资源|应用场景|首部字节  |
| --- | --- | --- | --- | --- | --- | --- | --- |
|TCP|面向连接|可靠|字节流|慢|多|要求通信数据可靠|20-60|
|UDP|无连接|不可靠|数据报文段|快|少|要求通信速度高|8个字节|

TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。

不使用「两次握手」和「四次握手」的原因：

「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；

「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

## TCP 的重传机制、滑动窗口、流量控制、拥塞控制

### 重传机制

TCP 实现可靠传输的方式之一，是通过序列号与确认应答。

在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。

但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？

所以 TCP 针对数据包丢失的情况，会用重传机制解决。

### 滑动窗口

我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。

这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的。

如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。

所以，这样的传输方式有一个缺点：数据包的往返时间越长，通信的效率就越低。

为解决这个问题，TCP 引入了窗口这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。

那么有了窗口，就可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。

### 流量控制

发送方不能无脑的发数据给接收方，要考虑接收方处理能力。

如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。

为了解决这种现象发生，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。

### 拥塞控制

前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。

一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。

在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….

所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。

于是，就有了拥塞控制，控制的目的就是避免「发送方」的数据填满整个网络。

为了在「发送方」调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念。

## TCP和UDP可以同时监听相同的端口吗

https://blog.51cto.com/u_12083623/2362539
https://blog.csdn.net/ma2595162349/article/details/108269351


TCP和UDP可以同时监听相同的端口吗(可以)

IP数据包首部有个叫做协议的字段，指出了上层协议是TCP还是UDP还是其他。操作系统有能力根据接受的报文的IP字段里面的协议部分判断这个报文是什么报文，就是说，系统读数据的时候还没有读到上层报文（TCP/UDP）的时候已经知道上层是什么报文了，直接交给相关的内核进程或协议栈处理就可以了。而在同一个协议内部端口号唯一。

## 刘超老师的课程

最后，我们看一下拥塞控制的问题，也是通过窗口的大小来控制的，前面的滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满。

这里有一个公式 LastByteSent - LastByteAcked <= min {cwnd, rwnd} ，是拥塞窗口和滑动窗口共同控制发送的速度。

顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的，这其实就相当于你领导和你的工作备忘录，布置过的工作要有编号，干完了有反馈，活不能派太多，也不能太少；

拥塞控制是通过拥塞窗口来解决的，相当于往管道里面倒水，快了容易溢出，慢了浪费带宽，要摸着石头过河，找到最优值。

## 参考资料

https://time.geekbang.org/column/article/9141